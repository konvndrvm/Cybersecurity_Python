#!/usr/bin/env python3
"""
malware_triage.py â€” Quick local triage of suspicious files

Performs lightweight static inspection:
- Computes file hashes (MD5, SHA1, SHA256)
- Detects packed or obfuscated executables via entropy and PE header hints
- Flags potential script droppers or macro documents
- Produces a short text report

No network calls or dependencies beyond the standard library.
"""

import os, sys, argparse, hashlib, math, struct
from pathlib import Path

BLOCKSIZE = 65536

def calc_hashes(path: Path):
    md5 = hashlib.md5()
    sha1 = hashlib.sha1()
    sha256 = hashlib.sha256()
    with open(path, "rb") as f:
        while chunk := f.read(BLOCKSIZE):
            md5.update(chunk)
            sha1.update(chunk)
            sha256.update(chunk)
    return md5.hexdigest(), sha1.hexdigest(), sha256.hexdigest()

def entropy(data: bytes) -> float:
    """Shannon entropy estimate (8-bit)."""
    if not data:
        return 0.0
    counts = [0] * 256
    for b in data:
        counts[b] += 1
    total = len(data)
    ent = 0.0
    for c in counts:
        if c:
            p = c / total
            ent -= p * math.log2(p)
    return ent

def detect_packers(path: Path) -> list[str]:
    """Detects PE or compressed payloads heuristically."""
    tags = []
    try:
        with open(path, "rb") as f:
            header = f.read(2048)
    except Exception as e:
        return [f"read_error:{e}"]

    # Generic PE signature
    if header[:2] == b"MZ":
        tags.append("pe_executable")
        if b"UPX" in header or b"upx" in header:
            tags.append("packed_upx")
        if b".text" not in header:
            tags.append("no_text_section")
    elif b"<script" in header.lower() or b"wscript" in header.lower():
        tags.append("script_dropper")
    elif header.startswith(b"PK") and b"macro" in header.lower():
        tags.append("macro_doc")
    return tags

def analyze(path: Path) -> dict:
    md5, sha1, sha256 = calc_hashes(path)
    tags = detect_packers(path)
    size = path.stat().st_size
    ent = 0.0
    try:
        with open(path, "rb") as f:
            data = f.read(min(size, 200000))  # sample up to 200KB
            ent = entropy(data)
    except Exception:
        pass
    if ent > 7.5:
        tags.append("high_entropy")
    verdict = "malicious" if any(t.startswith(("packed", "script", "macro")) for t in tags) else "suspicious" if ent > 7 else "benign"
    return {
        "file": str(path),
        "size": size,
        "entropy": round(ent, 2),
        "md5": md5,
        "sha1": sha1,
        "sha256": sha256,
        "tags": tags or ["none"],
        "verdict": verdict,
    }

def print_report(result: dict):
    print(f"File: {result['file']}")
    print(f"Size: {result['size']} bytes  Entropy: {result['entropy']}")
    print(f"MD5:    {result['md5']}")
    print(f"SHA1:   {result['sha1']}")
    print(f"SHA256: {result['sha256']}")
    print(f"Tags: {', '.join(result['tags'])}")
    print(f"Verdict: {result['verdict']}")
    print("-" * 70)

def self_test():
    """Basic self-test with random data."""
    import tempfile, random
    with tempfile.NamedTemporaryFile(delete=False) as tmp:
        tmp.write(os.urandom(4096))
        tmp_path = Path(tmp.name)
    res = analyze(tmp_path)
    print_report(res)
    tmp_path.unlink(missing_ok=True)

def main():
    ap = argparse.ArgumentParser(description="Offline simple malware triage tool")
    ap.add_argument("files", nargs="*", help="Files to triage")
    ap.add_argument("--self-test", action="store_true", help="Run built-in test")
    args = ap.parse_args()

    if args.self_test:
        self_test(); return
    if not args.files:
        print("Please specify one or more files, or use --self-test.", file=sys.stderr)
        sys.exit(1)

    for f in args.files:
        path = Path(f)
        if not path.exists():
            print(f"File not found: {path}", file=sys.stderr); continue
        result = analyze(path)
        print_report(result)

if __name__ == "__main__":
    main()
