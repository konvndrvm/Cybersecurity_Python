#!/usr/bin/env python3
"""
ioc_enricher.py â€” Offline Threat Intelligence Enrichment

Given a list of possible IOCs (Indicators of Compromise) such as IPs,
domains, or file hashes, this script performs basic *local* enrichment:
- Classify type (IPv4, domain, MD5/SHA)
- Check against known bad patterns and local reputation lists
- Identify suspicious features (e.g., numeric domains, odd TLDs, short hashes)
- Output a simple report table

No external lookups or APIs are used.
"""

import re, argparse, hashlib, sys, os
from pathlib import Path
from collections import Counter

# Example local "bad" indicators (extend for your org)
KNOWN_BAD_IPS = {"45.33.32.156", "185.220.101.1", "103.253.41.45"}
KNOWN_BAD_DOMAINS = {"malicious-example.com", "phish-login.net", "cryptominer.io"}
KNOWN_BAD_HASHES = {"44d88612fea8a8f36de82e1278abb02f"}  # EICAR test hash

IP_RE = re.compile(r"^(?:\d{1,3}\.){3}\d{1,3}$")
DOMAIN_RE = re.compile(r"^(?=.{3,255}$)([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}$")
MD5_RE = re.compile(r"^[a-fA-F0-9]{32}$")
SHA1_RE = re.compile(r"^[a-fA-F0-9]{40}$")
SHA256_RE = re.compile(r"^[a-fA-F0-9]{64}$")

def classify_ioc(ioc: str) -> str:
    if IP_RE.match(ioc): return "ip"
    if DOMAIN_RE.match(ioc): return "domain"
    if MD5_RE.match(ioc): return "md5"
    if SHA1_RE.match(ioc): return "sha1"
    if SHA256_RE.match(ioc): return "sha256"
    return "unknown"

def enrich_ioc(ioc: str) -> dict:
    kind = classify_ioc(ioc)
    score, tags = 0, []

    if kind == "ip":
        if ioc in KNOWN_BAD_IPS:
            tags.append("known_bad_ip"); score += 5
        if ioc.startswith("192.168.") or ioc.startswith("10."):
            tags.append("private_range"); score -= 2
    elif kind == "domain":
        if ioc in KNOWN_BAD_DOMAINS:
            tags.append("known_bad_domain"); score += 5
        if re.search(r"\d", ioc):
            tags.append("numeric_chars"); score += 1
        if any(ioc.endswith(tld) for tld in [".ru", ".tk", ".cn"]):
            tags.append("odd_tld"); score += 1
        if len(ioc.split(".")) > 4:
            tags.append("deep_subdomain"); score += 1
    elif kind in ("md5", "sha1", "sha256"):
        if ioc.lower() in KNOWN_BAD_HASHES:
            tags.append("known_bad_hash"); score += 5
        if len(set(ioc)) < 8:
            tags.append("low_entropy"); score += 1

    verdict = "malicious" if score >= 4 else "suspicious" if score >= 2 else "benign"
    return {"ioc": ioc, "type": kind, "score": score, "tags": tags, "verdict": verdict}

def analyze_file(path: Path):
    results = []
    with open(path, "r", encoding="utf-8", errors="ignore") as fh:
        for line in fh:
            ioc = line.strip()
            if not ioc: continue
            results.append(enrich_ioc(ioc))
    return results

def print_report(results):
    if not results:
        print("No indicators found.")
        return
    print(f"{'IOC':40} {'Type':8} {'Score':>5} {'Verdict':12} Tags")
    print("-" * 80)
    for r in results:
        tagstr = ",".join(r['tags']) if r['tags'] else "-"
        print(f"{r['ioc'][:40]:40} {r['type']:<8} {r['score']:>5} {r['verdict']:<12} {tagstr}")
    print("-" * 80)
    summary = Counter(r['verdict'] for r in results)
    print("Summary:", dict(summary))

def self_test():
    """Run a built-in sample test."""
    sample = [
        "45.33.32.156", "192.168.0.5", "malicious-example.com",
        "good.org", "abc123.ru", "44d88612fea8a8f36de82e1278abb02f",
        "f"*64
    ]
    results = [enrich_ioc(i) for i in sample]
    print_report(results)

def main():
    ap = argparse.ArgumentParser(description="Offline IOC Enrichment (no network)")
    ap.add_argument("file", nargs="?", help="Path to IOC list file (one per line)")
    ap.add_argument("--self-test", action="store_true", help="Run built-in test and exit")
    args = ap.parse_args()

    if args.self_test:
        self_test(); return
    if not args.file:
        print("Please provide a file or use --self-test", file=sys.stderr); sys.exit(1)

    path = Path(args.file)
    if not path.exists():
        print(f"File not found: {path}", file=sys.stderr); sys.exit(2)

    results = analyze_file(path)
    print_report(results)

if __name__ == "__main__":
    main()
